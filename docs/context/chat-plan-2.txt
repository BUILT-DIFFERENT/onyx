Below is a concrete, implementation-oriented plan to get your Android note-taking app (Onyx) to “Samsung Notes / Notewise tier” in architecture, features, performance, and visual quality, grounded in what’s already in your repo and the existing milestone plans.

I can’t browse the public web from this environment, so I’m using (1) your provided analyses + (2) what’s in the repo (plans + architecture review + current code patterns) as the truth source.

1) What “up to par” means (product bar)

From your provided comparisons (ChatGPT + Gemini), the competitive bar clusters into 4 pillars:

Library & organization

Grid thumbnails, fast browsing, folders (hierarchical), tags, pin/favorite, sort/filter, multi-select + batch ops.

Great search across: note titles, typed text, handwriting recognition, PDF text, and (eventually) OCR.

Editing & inking

Near-zero perceived latency, stable 60/90/120fps, no jank while writing + zooming.

Brush quality: smoothing/stabilization, pressure, taper, highlighter blending, consistent stroke joins.

Tools: pen/highlighter/eraser + lasso select, move/resize, copy/paste, shape tool, text boxes; optional images.

PDF as a first-class citizen

Fast open, page thumbnails, outline, search, text selection, highlight/ink annotations, “open to last page”, good caching.

Polish

Modern design system (tokens), coherent toolbar/panels, good animations, sensible defaults, persistence of tool settings.

Your repo already has explicit targets for this: the UI Overhaul plan calls out Samsung Notes + Notewise inspirations (single always-visible top bar, contextual tool panels, superior color picker, folder hierarchy, stabilization slider, stylus button actions, etc.) 

milestone-ui-overhaul-samsung-n…

.

2) Current-state gaps in the codebase (what to fix first)

Your internal android-architecture-review highlights the biggest blockers:

2.1 Inking performance / latency

You’re currently not using the low-latency path effectively: InProgressStrokesView exists but is set to fully transparent (alpha 0), and committed strokes are rendered in Compose by re-drawing all strokes each frame 

android-architecture-review

.

There’s additional perf waste from allocating Pair objects during point transforms on every point conversion 

android-architecture-review

.

2.2 Architecture / maintainability

ViewModels are currently defined inside composables and wired via custom factories, which makes DI/testing harder 

android-architecture-review

.

Plan A already outlines a manual DI pattern via OnyxApplication singletons (database/repository/device identity/MyScript engine) 

milestone-a-offline-ink-myscript

—but you’ll want to evolve it into clean boundaries (or Hilt later) once the app grows.

2.3 Persistence & schema readiness

Strokes are serialized as JSON → bytes and stored via base64 type converters 

android-architecture-review

 (fine for an MVP, but it’s a perf and DB-size tax at scale).

Room currently uses destructive migration fallback, which is not production-safe 

android-architecture-review

.

2.4 PDF performance + correctness risks

The PDF renderer has caching and lifecycle issues: LruCache sizing/usage is questionable and there’s risk of leaking native resources if Document/Page aren’t closed properly; also findCharAtPagePoint() is a brute-force loop across characters 

android-architecture-review

.

2.5 UI polish / feature wiring

Some toolbar icons aren’t wired, and the color picker is currently hex-only, with a hard-coded note paper color 

android-architecture-review

.

3) Target architecture (what to build toward)
3.1 Modules (recommended)

You don’t need a multi-module Gradle setup immediately, but you do need clear package/module boundaries:

A) app/ui

Compose screens, UI state models, navigation.

B) domain

Pure Kotlin use-cases (CreateNote, AddStroke, SearchNotes, RenderPageThumb, ImportPdf, etc.)

Interfaces (repositories/services) used by UI.

C) data

Room entities/DAOs, repository implementations, migrations, file storage (thumbnails, exports).

D) rendering

Ink rendering engine (low-latency path + committed-stroke cache)

PDF rendering/tiling

Thumbnail rendering pipeline

E) integrations

MyScript adapter (recognition + overlay)

MuPDF adapter

3.2 ViewModel strategy

Move ViewModels out of composables (the review calls the current pattern a maintainability issue 

android-architecture-review

).

Short-term: keep Plan A’s manual DI via OnyxApplication 

milestone-a-offline-ink-myscript

, but create:

HomeViewModel

NoteEditorViewModel

SettingsViewModel
in viewmodel/ with explicit constructor deps.

Mid-term: migrate to Hilt once the app stabilizes.

4) Roadmap (phased, with “what”, “how”, and “definition of done”)
Phase 0 — Performance baselining + guardrails (do this first)

Goal: Make improvements measurable and prevent regressions.

Work

Add instrumentation:

JankStats (frame time, dropped frames)

Macrobenchmark (startup, open note, pan/zoom with N strokes, PDF open)

Memory tracking (native + heap), bitmap allocation counts

Define budgets:

Ink latency perception: “no visible lag” (target: in-progress strokes drawn via low-latency path)

Panning/zoom: 60fps with 5k–20k strokes (device dependent)

PDF page render: cached <16ms, uncached <150ms (reasonable tablet target)

DoD

Benchmark suite runs in CI or at least locally with repeatable scenarios

Baseline numbers recorded before refactors

Phase 1 — Inking engine: low-latency + scalable committed rendering

This is your biggest competitive lever.

1.1 Fix low-latency in-progress strokes

Right now, low-latency drawing is effectively disabled (transparent) and you re-render via Compose 

android-architecture-review

.

Change

Render in-progress stroke using InProgressStrokesView (alpha restored).

Render committed strokes via a cached layer (bitmap tiles or per-page bitmap) that only updates on stroke commit/erase.

Plan A already anticipates Ink API compatibility concerns and suggests a fallback to CanvasFrontBufferedRenderer 

milestone-a-offline-ink-myscript

—build your renderer behind an interface so you can switch.

Implementation sketch

Introduce InkRenderer interface:

onPointerDown/Move/Up

commitStroke(Stroke)

erase(...)

renderCommittedLayer(canvas, viewport)

Backends:

InkApiRenderer (InProgressStrokesView)

FrontBufferedRenderer fallback 

milestone-a-offline-ink-myscript

1.2 Committed stroke rendering: tile cache

Compose “draw everything every frame” won’t scale 

android-architecture-review

.

Change

Use a tile-based renderer (same concept as Av2’s infinite canvas tiles) to cache committed strokes into bitmaps.

Tile size suggestion:

fixed pages: 512–1024 px tiles in screen-space or page-space

infinite pages: Av2 mandates 2024×2024 tiles 

milestone-av2-advanced-features

How

Maintain:

TileKey(pageId, tileX, tileY, scaleBucket)

LruCache for rendered tiles

On stroke commit:

compute stroke bounds → determine impacted tiles → redraw only those tiles (replay strokes intersecting tile bounds)

On pan/zoom:

draw visible tiles only (culling)

allow temporary low-res tiles while high-res renders async

1.3 Reduce per-point allocations

The review notes Pair allocation overhead during point transforms 

android-architecture-review

.

Change

Replace Pair<Float,Float> with:

inline value class Vec2(val x: Float, val y: Float) or

write results into a reusable float array / small mutable struct.

DoD for Phase 1

Inking remains smooth at high stroke counts

Pan/zoom doesn’t degrade linearly with total strokes

Measurable reduction in allocations and jank

Phase 2 — Storage & schema: fast, sync-ready, production-safe
2.1 Replace destructive migration

Room currently uses destructive migration fallback 

android-architecture-review

.

Change

Enable schema export

Implement real migrations for each version bump

Add “db integrity check” tests

2.2 Stroke serialization: move off JSON/base64

Right now stroke points are serialized as JSON→bytes and stored using base64 converters 

android-architecture-review

.

Change

Introduce a compact binary format for points (even before Protobuf):

fixed-width float packing or varint delta encoding (x/y deltas + pressure)

optional compression (LZ4) if needed

Migration plan

Keep reading old JSON format for existing rows

On load, lazily re-encode into binary and update rows (or run a one-time migration)

DoD

DB size shrinks materially on large notes

Save/load is faster; fewer GC spikes

Phase 3 — UI overhaul + organization (bring the app “up to par” visually)

Use your existing UI Overhaul plan as the implementation target.

3.1 Design system tokens (dark theme + semantic tokens)

UI Overhaul specifies adding new semantic tokens and where to place them 

milestone-ui-overhaul-samsung-n…

.

Change

Create Color.kt semantic tokens (bgPrimary, surface, textPrimary, etc.) per plan 

milestone-ui-overhaul-samsung-n…

.

Unify spacing, corner radii, typography styles from the plan.

3.2 Implement folders, templates, preferences entities

UI Overhaul explicitly defines new DB entities (folders, note_folders junction, user_preferences, templates, stylus preferences) 

milestone-ui-overhaul-samsung-n…

.

Work

Add entities + DAOs

Add migrations

Update repository surface:

folder-aware queries (the plan outlines needed repo methods) 

milestone-ui-overhaul-samsung-n…

3.3 Home/library screen: grid thumbnails + fast browsing

Change

Add note thumbnails:

background job renders first page preview into a file cache

store thumbnail path + updatedAt hash

Add:

grid/list toggle

sort menu (updated, created, title)

long-press multi-select with batch ops (move to folder, delete, export)

3.4 Editor chrome: Samsung Notes x Notewise pattern

Match your plan’s stated inspirations (single always-visible top bar, contextual panels, stabilization slider, movable scrollbar, etc.) 

milestone-ui-overhaul-samsung-n…

.

Key editor UX upgrades

Always-visible top pill groups (nav/title, tools/colors, actions)

Context panels per tool:

Pen: size, opacity, stabilization slider (0–10 per plan) 

milestone-ui-overhaul-samsung-n…

Highlighter: opacity + blend mode

Eraser: stroke/segment toggle (segment in Av2)

Better color picker: spectrum + swatches + hex (plan calls this out) 

milestone-ui-overhaul-samsung-n…

Persist settings via UserPreferenceEntity 

milestone-ui-overhaul-samsung-n…

DoD for Phase 3

Home screen feels modern and fast

Editor tool UX matches the plan’s interaction model

User settings persist reliably

Phase 4 — PDF experience: “first class”, fast, and correct

Architecture review flags the PDF renderer risks and inefficiencies 

android-architecture-review

.

4.1 Fix lifecycle + caching

Change

Ensure every MuPDF Document/Page is closed deterministically 

android-architecture-review

.

Rework bitmap caching:

cache by (docId, pageIndex, scaleBucket)

use bitmap pool to reuse allocations

render on background dispatcher; deliver via StateFlow

4.2 Add PDF UI essentials

Page thumbnails strip

Outline (table of contents)

Text search + highlight

Text selection (and copy)

Annotation tools: pen + highlighter + shapes (phase-dependent)

DoD

No memory leaks across repeated PDF opens

PDF navigation and annotation feels comparable to competitors

Phase 5 — “Advanced” parity features (Av2 + competitive must-haves)

Your Av2 milestone defines the big-ticket features: infinite canvas tile system, required segment eraser, batch recognition, recognition overlay 

milestone-av2-advanced-features

.

5.1 Segment eraser (must-have)

Av2 mandates segment eraser behavior (split strokes at erase point) 

milestone-av2-advanced-features

.

Implementation

Add stroke segment data model:

either store split strokes as new stroke rows with lineage

or store “stroke fragments” with stable IDs

Use a robust splitting algorithm:

find intersections with eraser path

break polyline into multiple strokes

preserve style + timestamps

5.2 Recognition overlay + lasso convert

Overlay recognized text (toggle)

Lasso select region → convert handwriting to text block

Batch recognition pipeline (throttled) 

milestone-av2-advanced-features

5.3 Infinite canvas

Use Av2’s tile approach (2024×2024) 

milestone-av2-advanced-features

Share the same tile renderer concepts you built in Phase 1 for committed ink

DoD

Segment eraser feels “native”, not gimmicky

Recognition overlay is stable and matches ink locations

Infinite canvas can scale without perf collapse

5) Visual quality upgrades (brushes + UI polish)
5.1 Brush rendering pipeline

To compete visually, move from “polyline drawLine” to a higher quality stroke model:

Pen

spline smoothing (Catmull-Rom → Bezier)

variable width from pressure + velocity

taper at endpoints

consistent joins (miter limit) and caps

Highlighter

constant width, lower opacity

proper blend mode (multiply/overlay style)

optional “don’t darken on overlap” (competitor-like)

Stabilization

slider 0–10 (UI Overhaul calls this out) 

milestone-ui-overhaul-samsung-n…

implement as a tunable low-pass filter or Kalman-like smoothing

5.2 UI consistency via tokens

Follow UI Overhaul’s token plan (semantic colors, typography, spacing) 

milestone-ui-overhaul-samsung-n…

.

Add component library: pill groups, icon buttons, sliders, floating panels.

Animate panel appearance/disappearance and tool selection states.

6) Documentation deliverables (so this stays “well documented”)

Create a /docs/android/ folder and ship these as part of the work:

ARCHITECTURE.md

module boundaries, data flow, threading rules, DI approach

ViewModel/state conventions

RENDERING.md

ink pipeline: in-progress vs committed, tile cache, scale buckets, invalidation strategy

perf budgets and how to profile

STORAGE.md

schema overview, migrations, stroke binary format spec, thumbnail cache spec

PDF.md

MuPDF lifecycle rules, caching approach, render queue, memory limits

FEATURE-SPECS/

folders & templates (based directly on UI Overhaul entity/DAO requirements 

milestone-ui-overhaul-samsung-n…

)

segment eraser & infinite canvas (based on Av2 requirements 

milestone-av2-advanced-features

)

QUALITY.md

benchmark scenarios, regression thresholds, test matrix (tablet models, stylus types)

7) Recommended “first 2 weeks” task order (highest leverage)

Based on your current blockers:

Enable real low-latency inking (fix InProgressStrokesView usage + committed stroke caching) 

android-architecture-review

Remove destructive migrations + add schema exports 

android-architecture-review

Fix PDF lifecycle/caching correctness 

android-architecture-review

Start design token refactor (Color.kt semantic tokens) 
Add folders/preferences entities so the UI Overhaul can land cleanly